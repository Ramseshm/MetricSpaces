# -*- coding: utf-8 -*-
"""mifi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bnvjDQyd70fVYmHO8su__CH5-vqWae0b
"""

from ..Spaces import Space
import random

class algo:
  def __init__(self,args=list()):
    if(len(args)==0):
      self.nro=0
      self.db=None
      self.space=None
      self.index_name=None
    else:
      self.db=args[0]
      self.nro=args[1][0]
      self.m_i=args[1][1]
      self.m_s=args[1][2]
      self.space=Space.load_space("vectors")
      self.index_name=None

  def set_bd(self,db):
    self.db=db

  def set_index_name(self,name):
    self.index_name=name
  
  def set_space(self,space):
    self.space=Space.load_space(space)

  def get_index_name(self):
    return self.index_name

  def get_algorithm(self):
    return "mifi"

  def config(self,**kwargsv):
    self.nro=kwargsv["nro"]
    self.m_i=kwargsv["mi"]
    self.m_s=kwargsv["ms"]
  
  def ordenar(self,l1):
    l1.sort(key=lambda elem: elem[1])
    aux=list()
    for i in l1:
      aux.append(i[0])
    return aux
  
  def search_radius(self,can,r):
    result=list()
    for x in can:
      distqu=self.space.Distance(0,x)
      if(distqu<=r):
        result.append(x)
    return result

  def search_knn(self,can,k):
    r=99999
    nn=list()
    for x in can:
      if(len(nn)==k):
        r=max(nnaux)
        if(self.space.Distance(0,x)<r):
          nn[-1]=x
          nnaux[-1]=self.space.Distance(0,x)
          aux1=list()
          nnaux1=nnaux.copy()
          nnaux1.sort()
          for i in nnaux1:
            aux1.append(nn[nnaux.index(i)])
          nn=aux1
          nnaux=nnaux1
      else:
        aux1=list()
        nn.append(x)
        nnaux.append(self.space.Distance(0,x))
        nnaux1=nnaux.copy()
        nnaux1.sort()
        for i in nnaux1:
          aux1.append(nn[nnaux.index(i)])
        nn=aux1
        nnaux=nnaux1
    return nn

  def build(self):
  
    x=self.space.loadDB(self.db)
  
    RO=list()
    while(len(RO)<self.nro):
      P=random.randint(1,(self.space.tam()))
      #P=random.randint(1,30)
      if(P not in RO):
        RO.append(P)
    
    obj_trans=[0]
    for i in range(1,(self.space.tam())):
    #for i in range(1,30):
      aux=[]
      for ro in RO:
        aux.append((RO.index(ro)+1,self.space.Distance(i,ro)))
      obj_trans.append(self.ordenar(aux)[:self.m_i])

 
    inverted_file=[[]]
    for i in range(1,len(RO)+1):
      #pl_i=list()
      pl_i=[-1]*(len(obj_trans)-1)
      for j in range(1,len(obj_trans)):
        if(i in obj_trans[j]):
          pl_i[j-1]=obj_trans[j].index(i)+1
          #pl_i.append((j,obj_trans[j].index(i)+1))
        
      inverted_file.append(pl_i)
  
    indice={"db":self.db,
            "RO":RO,
            "mifi":inverted_file,
            "ks":self.m_s,
            "ki":self.m_i,
            "space":self.space.name(),
            "algorithm":"mifi",
            }

    return indice

  def query(self,index_m,q,r):
 
    x=self.space.loadDB(self.db)
  
    self.space.add(q)
    q_dist=list()
    for ro in index_m["RO"]:
      q_dist.append((index_m["RO"].index(ro)+1,self.space.Distance(0,ro)))

    index_m["mifi"][0]=self.ordenar(q_dist)[:index_m["ks"]]
  #print(index_m["mifi"][0])
  
    A=[0]*(len(index_m["mifi"][1]))
    for ro in index_m["mifi"][0]:
      pl=index_m["mifi"][ro]
      for i in range(len(pl)):
        if(pl[i] !=-1):
          if(A[i]==0):
            A[i]=(index_m["ki"]+1)*index_m["ks"]
          A[i]=A[i]-(index_m["ki"]+1)+abs((index_m["mifi"][0].index(ro)+1)-pl[i])


    candidatos=self.ordenar(list(enumerate(A,1)))
  #candidatos=ordenar(list(enumerate(A,1)))
  #print(candidatos)
    result=list()
    if(r>0):
      results=self.search_radius(q,r)
    else:
      results=self.search_knn(q,int(abs(r)))
    return results