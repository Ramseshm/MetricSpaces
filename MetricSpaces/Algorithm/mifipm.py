# -*- coding: utf-8 -*-
"""mifipm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CuhhG3giHf-OYn5nbwVN5tCnUw4Ss62d
"""

from ..Spaces import Space
import random

class algo:
  def __init__(self,args=list()):
    if(len(args)==0):
      self.nro=0
      self.db=None
      self.space=None
      self.index_name=None
    else:
      self.db=args[0]
      self.nro=args[1][0]
      self.m_i=args[1][1]
      self.m_s=args[1][2]
      self.space=Space.load_space("vectors")
      self.index_name=None

  def set_bd(self,db):
    self.db=db

  def set_index_name(self,name):
    self.index_name=name
  
  def set_space(self,space):
    self.space=Space.load_space(space)

  def get_index_name(self):
    return self.index_name

  def get_algorithm(self):
    return "mifipm"

  def config(self,**kwargsv):
    self.nro=kwargsv["nro"]
    self.m_i=kwargsv["mi"]
    self.m_s=kwargsv["ms"]
  
  def ordenar(self,l1):
    l1.sort(key=lambda elem: elem[1])
    aux=list()
    for i in l1:
      aux.append(i[0])
    return aux

  def search_radius(self,can,r):
      result=list()
      for x in can:
        distqu=self.space.Distance(0,x)
        if(distqu<=r):
          result.append(x)
      return result

  def search_knn(self,can,k):
      r=99999
      nn=list()
      for x in can:
        if(len(nn)==k):
          r=max(nnaux)
          if(self.space.Distance(0,x)<r):
            nn[-1]=x
            nnaux[-1]=self.space.Distance(0,x)
            aux1=list()
            nnaux1=nnaux.copy()
            nnaux1.sort()
            for i in nnaux1:
              aux1.append(nn[nnaux.index(i)])
            nn=aux1
            nnaux=nnaux1
        else:
          aux1=list()
          nn.append(x)
          nnaux.append(self.space.Distance(0,x))
          nnaux1=nnaux.copy()
          nnaux1.sort()
          for i in nnaux1:
            aux1.append(nn[nnaux.index(i)])
          nn=aux1
          nnaux=nnaux1
      return nn

  def build(self):
      """
        CARGAR DE BASE DE DATOS
      """
      x=self.space.loadDB(self.db)
      
      """
        SELECCION DE LOS OBJETOS DE REFERENCIA
      """
      RO=list()
      while(len(RO)<self.nro):
        P=random.randint(1,(self.space.tam()))
        #P=random.randint(1,30)
        if(P not in RO):
          RO.append(P)
        
      """
        TRANSFORMACIÓN DE LOS OBJETOS CON TAMAÑO K_I 
      """
      obj_trans=[0]
      for i in range(1,(self.space.tam())):
      #for i in range(1,30):
        aux=[]
        for ro in RO:
          aux.append((RO.index(ro)+1,self.space.Distance(i,ro)))
        obj_trans.append(self.ordenar(aux)[:self.m_i])

      """
        CREACION DEL INDICE INVERTIDO CON LOS OBJETOS TRANSFORMADOS
          -INDEXACION DE OBJETOS
      """

      inverted_file=[[]]

      for i in range(1,len(RO)+1):
        #pl_i=list()
        pl_i=list()
        for j in range(1,len(obj_trans)):
          if(i in obj_trans[j]):
            pl_i.append(j) #almacena solo el indice del elemento 
            #pl_i.append((j,obj_trans[j].index(i)+1))
            
        inverted_file.append(pl_i)
      
      """
      CREACION DE DICCIONARIO CON INFORMACIÓN NECESARIA PARA LA CONSULTA
      """
      indice={"db":self.db,
              "RO":RO,
              "mifi":inverted_file,
              "ks":self.m_s,
              "ki":self.m_i,
              "per":obj_trans,
              "space":self.space.name(),
              "algorithm":"mifipm",
              }

      return indice

  def query_trans(self,l1,alpha,r,ms):
      l1.sort(key=lambda elem: elem[1])
      msr=1
      if(r>0):
        d_u=l1[0][1]+ (alpha*r)
      else:
        d_u=l1[0][1]+ (alpha*l1[abs(r)-1][1])

      for i in range(ms):
        if(l1[i][1]<=d_u):
          msr=msr+1

    
      return self.ordenar(l1),msr

  def union_pl(self,index,msr):
    pre_c=set()
    for x in index["per"][0][:msr]:
      pre_c=pre_c.union(set(index["mifi"][x]))
    return list(pre_c)

  def query(self,index_m,q,r):
      """
        TRANSFORMACION DE LA CONSULTA CON TAMAÑO VARIABLE SEGUN alpha ,d*_u_1 Y ks
      """
      x=self.space.loadDB(self.db)
      
      self.space.add(q)
      q_dist=list()
      for ro in index_m["RO"]:
        q_dist.append((index_m["RO"].index(ro)+1,self.space.Distance(0,ro)))

      index_m["per"][0],msr=self.query_trans(q_dist,alpha,r,index_m["ks"])
      #print(index_m["mifi"][0])

      pre_candidatos=self.union_pl(index_m,msr)


      """
        SELECCIÓN DE CANDIDATOS DENTRO DEL INDICE INVERTIDO
      """
      """
      A=[0]*(len(index_m["mifi"][1]))
      for ro in index_m["per"][0]:
        pl=index_m["mifi"][ro]
        for i in range(len(pl)):
          if(pl[i] !=-1):
            if(A[i]==0):
              A[i]=(index_m["ki"]+1)*index_m["ks"]
            A[i]=A[i]-(index_m["ki"]+1)+abs((index_m["mifi"][0].index(ro)+1)-pl[i])
      """
      aux=list()
      for u in pre_candidatos:
        s=0
        p_u=index_m["per"][u]
        for i in range(len(p_u)):
          s=s+abs((i+1)-(index_m["per"][0].index(p_u[i])+1))
        aux.append((u,s))

      candidatos=self.ordenar(aux)
      #candidatos=ordenar(list(enumerate(A,1)))
      #print(candidatos)
      result=list()
      if(r>0):
        results=self.search_radius(q,r)
      else:
        results=self.search_knn(q,int(abs(r)))
      return results